{"version":3,"sources":["../src/AppImageUpdater.ts"],"names":[],"mappings":"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","sourcesContent":["import { AllPublishOptions, newError } from \"builder-util-runtime\"\nimport { execFileSync, spawn } from \"child_process\"\nimport { chmod } from \"fs-extra\"\nimport { unlinkSync } from \"fs\"\nimport * as path from \"path\"\nimport { DownloadUpdateOptions } from \"./AppUpdater\"\nimport { BaseUpdater, InstallOptions } from \"./BaseUpdater\"\nimport { DifferentialDownloaderOptions } from \"./differentialDownloader/DifferentialDownloader\"\nimport { FileWithEmbeddedBlockMapDifferentialDownloader } from \"./differentialDownloader/FileWithEmbeddedBlockMapDifferentialDownloader\"\nimport { DOWNLOAD_PROGRESS } from \"./main\"\nimport { findFile } from \"./providers/Provider\"\n\nexport class AppImageUpdater extends BaseUpdater {\n  constructor(options?: AllPublishOptions | null, app?: any) {\n    super(options, app)\n  }\n\n  public isUpdaterActive(): boolean {\n    if (process.env.APPIMAGE == null) {\n      if (process.env.SNAP == null) {\n        this._logger.warn(\"APPIMAGE env is not defined, current application is not an AppImage\")\n      }\n      else {\n        this._logger.info(\"SNAP env is defined, updater is disabled\")\n      }\n      return false\n    }\n    return super.isUpdaterActive()\n  }\n\n  /*** @private */\n  protected doDownloadUpdate(downloadUpdateOptions: DownloadUpdateOptions): Promise<Array<string>> {\n    const provider = downloadUpdateOptions.updateInfoAndProvider.provider\n    const fileInfo = findFile(provider.resolveFiles(downloadUpdateOptions.updateInfoAndProvider.info), \"AppImage\")!!\n    return this.executeDownload({\n      fileExtension: \"AppImage\",\n      fileInfo,\n      downloadUpdateOptions,\n      task: async (updateFile, downloadOptions) => {\n        const oldFile = process.env.APPIMAGE!!\n        if (oldFile == null) {\n          throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n        }\n\n        let isDownloadFull = false\n        try {\n          const downloadOptions: DifferentialDownloaderOptions = {\n            newUrl: fileInfo.url,\n            oldFile,\n            logger: this._logger,\n            newFile: updateFile,\n            isUseMultipleRangeRequest: provider.isUseMultipleRangeRequest,\n            requestHeaders: downloadUpdateOptions.requestHeaders,\n            cancellationToken: downloadUpdateOptions.cancellationToken,\n          }\n\n          if (this.listenerCount(DOWNLOAD_PROGRESS) > 0) {\n            downloadOptions.onProgress = it => this.emit(DOWNLOAD_PROGRESS, it)\n          }\n\n          await new FileWithEmbeddedBlockMapDifferentialDownloader(fileInfo.info, this.httpExecutor, downloadOptions)\n            .download()\n        }\n        catch (e) {\n          this._logger.error(`Cannot download differentially, fallback to full download: ${e.stack || e}`)\n          // during test (developer machine mac) we must throw error\n          isDownloadFull = process.platform === \"linux\"\n        }\n\n        if (isDownloadFull) {\n          await this.httpExecutor.download(fileInfo.url, updateFile, downloadOptions)\n        }\n\n        await chmod(updateFile, 0o755)\n      },\n    })\n  }\n\n  protected doInstall(options: InstallOptions): boolean {\n    const appImageFile = process.env.APPIMAGE!!\n    if (appImageFile == null) {\n      throw newError(\"APPIMAGE env is not defined\", \"ERR_UPDATER_OLD_FILE_NOT_FOUND\")\n    }\n\n    // https://stackoverflow.com/a/1712051/1910191\n    unlinkSync(appImageFile)\n\n    let destination: string\n    const existingBaseName = path.basename(appImageFile)\n    // https://github.com/electron-userland/electron-builder/issues/2964\n    // if no version in existing file name, it means that user wants to preserve current custom name\n    if (path.basename(options.installerPath) === existingBaseName || !/\\d+\\.\\d+\\.\\d+/.test(existingBaseName)) {\n      // no version in the file name, overwrite existing\n      destination = appImageFile\n    }\n    else {\n      destination = path.join(path.dirname(appImageFile), path.basename(options.installerPath))\n    }\n\n    execFileSync(\"mv\", [\"-f\", options.installerPath, destination])\n    if (destination !== appImageFile) {\n      this.emit('appimage-filename-updated', destination)\n    }\n\n    const env: any = {\n      ...process.env,\n      APPIMAGE_SILENT_INSTALL: \"true\",\n    }\n\n    if (options.isForceRunAfter) {\n      spawn(destination, [], {\n        detached: true,\n        stdio: \"ignore\",\n        env,\n      })\n        .unref()\n    }\n    else {\n      env.APPIMAGE_EXIT_AFTER_INSTALL = \"true\"\n      execFileSync(destination, [], {env})\n    }\n    return true\n  }\n}\n"],"sourceRoot":""}
